<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="utf-8" />
  <script type="text/javascript" src="Scripts/konva.min.js"></script>
  <script type="text/javascript" src="Scripts/multithread.js"></script>
  <script type="text/javascript" src="Scripts/jscolor.js"></script>
  <link rel="stylesheet" type="text/css" href="Style/style.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <script type="text/javascript" src="Scripts/MeineFunktionen.js"></script>
  <script type="text/javascript" src="Scripts/read-csv.js"></script>
  <title>Zeichenfeld</title>
</head>

<body>
  <div id="wrapper">
    <nav id="nav">
      <ul id="navigation">
        <li><a ontouchstart="showSomething('closeUL1')">Basics &raquo;</a>
          <ul id="closeUL1">
            <li>
              <span>Werkzeugeinstellungen</span>
              <div id="mdiv1" class="odiv" ontouchstart="hideSomething('closeUL1')">
                <div class="mdiv">
                  <div class="md">
                  </div>
                </div>
              </div>
            </li>
            <li><span class="tool">
                Hintergrund:
                <select id="hintergrund" class="style" onchange="changeToolBackground()">
                  <option title="" value=7>Kariert</option>
                  <option title="" value=6>Linien</option>
                  <option title="" value=8>Millimeter</option>

                  <option title="" value=1>KOS 1 (VDR)</option>
                  <option title="" value=2>KOS 2 (Batterie und Netzteil)</option>
                  <option title="" value=4>KOS 3 (Solarzelle)</option>
                  <option title="" value=10>KOS 4 (Kondensator)</option>
                  <option title="" value=11>KOS 5 (Impedanz)</option>
                  <option title="" value=12>KOS 6 (Amp/log)</option>
                  <option title="" value=13>KOS 7 (phi/log)</option>

                  <option title="" value=5>Osziloskop (DIV)</option>
                  <option title="" value=9>Osziloskop (Magnetisch)</option>


                  <script type="text/javascript">
                    var sources = ["", "Data/P1_3.png", "Data/P2_10.svg", "Data/P2_11.png", "Data/P2_11.svg", "Data/P3.svg", "Data/grid.png", "Data/invisible.svg", "Data/mill_norm_a4.svg", "Data/P3_7.svg", "Data/P3_9.svg", "Data/P4_3.svg",
                      "Data/mill_log_a4_achsen_einzeln_A.svg",
                      "Data/mill_log_a4_achsen_einzeln_phi.svg"
                    ];
                    //             0      1           2           3                4          5           6              7             8                9           10          11                12                                 13
                  </script>

                </select>
              </span></li>
            <li><span class="tool">
                Tool:
                <select id="Zeichentool" class="style">
                  <option value="brush">Stift</option>
                  <option value="eraser">Radiergummi</option>
                </select>
              </span></li>
            <li> <span class="tool">
                Gr&ouml;ße:
                <select id="pix" class="style">
                  <option value=1>1</option>
                  <option value=3>3</option>
                  <option value=5>5</option>
                  <option value=10>10</option>
                  <option value=15>15</option>
                  <option value=20>20</option>
                </select> pix
              </span></li>
            <li> <span class="tool">
                Farbauswahl:
                <input type="color" id="pencilColor" name="pencilColor" value="#000000" onchange="updateColor()">
              </span></li>
            <li>
              <span id="clear" class="tool">
                <button id="Clear Context" class="style" onclick="clearContext()"> L&ouml;sche Handschrift </button>
              </span>
            </li>
            <li>
              <span id="export" class="tool">
                <input id="exportInput" type="text" class="tableInput" placeholder="ZT.png">
                <input id="exportBtn" type="button" class="style" value="Download" onclick="downloadPic()">
              </span>
            </li>
          </ul>
        </li>
        <li><a> <button id="myBtn" class="helpButton"> Hilfe </button></a></li>
        <li><a ontouchstart="showSomething('closeUL2')">Erstelle &raquo;</a>
          <ul id="closeUL2">
            <li>
              <span>Objekteinstellungen</span>
              <div id="mdiv2" class="odiv" ontouchstart="hideSomething('closeUL2')">
                <div class="mdiv">
                  <div class="md"></div>
                </div>
              </div>
            </li>
            <li>
              <div id="tabelle" class="tool" style="max-height: 50vh; overflow-y: scroll; max-width: 33vw; overflow-x: scroll;">
                <span id="Tabfeld">
                  <table border="1" id="tableTable" class="wertetabelle">
                    <td>
                      <input type="Text" id="Graph1" class="tableInput" value="Graph1">
                      <table border="1" id="dataTable" class="wertetabelle">
                        <thead>
                          <tr>
                            <td>
                              <Strong>Ordinate</Strong>
                            </td>
                            <td>
                              <Strong>Abzisse</Strong>
                            </td>
                          </tr>
                        </thead>
                        <tbody>
                          <tr>
                            <td>
                              <input type="Text" class="tableInput">
                            </td>
                            <td>
                              <input type="Text" class="tableInput">
                            </td>
                          </tr>
                        </tbody>
                      </table>
                      <p><button class="style" onclick="addRow('dataTable')" />Add Row</button>
                        <button class="style" onclick="deleteRow('dataTable')" />Delete Row</button>
                      </p>
                      <p><button id="showGraph" class="style" onclick="readpoints('dataTable','dGraph','showGraph','Graph1')" />Show</button>
                        <button id="dGraph" class="style" />Delete Graph</button>
                      </p>
                    </td>
                  </table>
                </span>
              </div>
            </li>
            <li>
              <span id="Wertetabellen" class="tool">
                <button class="style" onclick="insertNewWertetabelle('tableTable')" />neue Wertetabelle</button>
                <!-- <button class="style" onclick="" />Lösche letzte Wertetabelle</button>  zum löschen der einzelen tabenn soon-->
              </span>
            </li>
            <li>
              <span id="Textfeld" class="tool">
                <button id="Textfeld" class="style" onclick="createTextfeld()"> neues Textfeld </button>
              </span>
            </li>
            <li>
              <span id="Linefeld" class="tool">
                <button id="Gerade" class="style" onclick="createLine()"> neue Gerade </button>
              </span>
            </li>
            <li>
              <span id="VektorStuff" class="tool">
                <button class="style" onclick="newArrow()"> neuen Vektor </button>
                <!-- <button class="style" onclick="" />Lösche letzte Wertetabelle</button>  zum löschen der einzelen tabenn soon-->
              </span>
            </li>
            <li>
              <span id="Linefeld" class="tool">
                Lade Bild: <input type="file" accept="image/*" id="pic" onchange="preview_image(event)" class="style">
              </span>
            </li>
            <li>
              <div class="tool">
                <span id="CSVDateiCH2">
                  <p style="color: blue;">
                    Lade CSV in CH1: <input type="file" id="csvFileInput" onchange="handleFiles(this.files,1)" accept=".csv">
                  </p>
                  <div style="text-align:left;">
                    <p>
                      Qualität: High <input id="quali1" type="range" min="121" max="8001" value="8001"> Low
                    </p>
                    <p id="LoadingAniCH1"> Loading...</p>
                    <script type="text/javascript">
                      randomColor("LoadingAniCH1");
                      setContentVisabillity("LoadingAniCH1", false);
                    </script>
                  </div>
                </span>
              </div>
              <div class="tool">
                <span id="CSVDateiCH2">
                  <p style="color: green;">
                    Lade CSV in CH2: <input type="file" id="csvFileInput" onchange="handleFiles(this.files,2)" accept=".csv">
                  </p>
                  <div style="text-align:left;">
                    <p>
                      Qualität: High <input id="quali2" type="range" min="121" max="8001" value="8001"> Low
                    </p>
                    <p id="LoadingAniCH2"> Loading...</p>
                    <script type="text/javascript">
                      randomColor("LoadingAniCH2");
                      setContentVisabillity("LoadingAniCH2", false);
                    </script>
                  </div>
                </span>
              </div>
            </li>
          </ul>
        </li>
      </ul>
    </nav>

    <!-- The Modal -->
    <div id="myModal" class="modal">
      <!-- Modal content -->
      <div class="modal-content">
        <div id="closeModal" class="odiv">
          <div class="mdiv">
            <div class="md"></div>
          </div>
        </div>

        <div id="capture" style="padding: 10px; background: lightgray;">
          <h4 style="color: #000; ">Dokumentation</h4>
        </div>

        <div class="helpDIV">
          <h1 class="helpH1">Hilfe zu den Basics:</h1>
          <img src="Data/BasicHelp.gif" class="helpIMG">
          <div class="helpP">Das ist die integrierte Eingabemöglichkeit des Protokolls. Sie besteht aus zwei grundlegenden Bereichen
            dem Bedienfeld und dem Zeichenfeld. Das Bedienfeld ist in drei Spalten unterteilt, diese werden später genauer
            beschrieben. Das Zeichenfeld ist der rot umrahmte Bereich. Die erste Spalte
            befasst sich mit der handschriftlichen Bearbeitung des Zeichenfeldes. Hier können für die Werkzeuge Stift und
            Radiergummi die Breite eingestellt werden (Hinweis: Die Breite bezieht sich auf beide Werkzeuge). Außerdem ist
            es möglich die Mienenfarbe des Stiftes einzustellen. Der Button mit der Aufschrift "Lösche Handschrift" löscht lediglich
            den Handbeschriebenen Layer. Mit dem Tool Hintergrund können Sie einen geeigneten Hintergrund festlegen.
          </div>
        </div>

        <div class="helpDIV">
          <h1 class="helpH1">Hilfe zur Funktion aus einer Wertetabelle:</h1>
          <img src="Data/WertetabelleHelp.gif" class="helpIMG">
          <div class="helpP">Zu Beginn ist eine Beispielwertetabelle zu sehen. Jede Wertetabelle besitzt vier Schaltflächen, welche nur zur
            Bedienung der darüber befindlichen Punktewolke vorgesehen sind. Die Schaltflächen "Add Row" und "Delete Row" erm&ouml;glichen es
            einen weiteren Punkt hinzuzuf&uuml;gen oder den letzten Punkt zu l&ouml;schen. Die Schaltfläche Show zeichnet die Punkte der
            Reihe nach in das jeweilige KOS. Punkte welche sich außerhalb des darstellbaren Berreiches befinden, werden imaginär gesetzt.
            Das bedeutet die Kurve wird dennoch von diesen Punkten beinflusst. Jeder Graph kann unter zuhilfenahme des oberen Inputfeldes benannt werden.
            Der Name erscheint dann im Label, dass in gleicher Farbe wie der Graph im Zeichenfeld gerendert wird. Mit dem Button "neue Wertetabelle"
            können beliebig viele weitere Punktewolken erschaffen werden.
          </div>
        </div>

        <div class="helpDIV">
          <h1 class="helpH1">Hilfe zur Textfeldfuntion:</h1>
          <img src="Data/TextfeldHelp.gif" class="helpIMG">
          <div class="helpP">Mit betätigung der Schaltfläche "neues Textfeld" erscheint ein solches in dem Zeichenfeld. Das Zeichenfeld wird mit
            einem Doppelklick in den Bearbeitungsmodus versetzt. Daraufhin verschwindet der Blaue Rahmen und die zwei runden Schaltflächen. Jetzt
            kann der Text bearbeitet werden. Ein Zeilenumbruch kann mit der Tastenkombination Shift+Enter eingefügt werden. Die Höhe des Textfeldes
            wird automatisch an den Inhalt angepasst. Ist man mit dem bearbeiten des Textes fertig, so bestätigt man seine eingabe mit Enter. Mithilfe
            des kleinen Rechtecks am rechten Rand kann die Breite festgelegt werden. Und mit dem anderen kann der Text um den eigenen Mittelpunkt gedreht werden.
            Die rote Schaltfläche löscht das dazugehörige Textfeld. Mit dem grauen Button kann der blaue Rahmen, falls nötig, versteckt werden.


          </div>
        </div>

        <div class="helpDIV">
          <h1 class="helpH1">Hilfe zur Geradenfunktion:</h1>
          <img src="Data/GeradeHelp.gif" class="helpIMG">
          <div class="helpP">Mit einem Klick auf den entsprechenden Button erscheint eine Gerade im Zeichenfeld. Die Gerade hat an ihren beiden Enden zwei
            individuell bewegbare graue, schwarz umrandete Flächen. Durch deren Mittelpunkte ist die Gerade definiert. Mit dem bunten Knopf an oberen Rand
            kann die Farbe Zufällig verändert werden. Die rote Schaltfläche löscht die Gerade.
          </div>
        </div>

        <div class="helpDIV">
          <h1 class="helpH1">Hilfe zu der Vektorenfunktion:</h1>
          <img src="Data/VektorHelp.gif" class="helpIMG">
          <div class="helpP">Ein Vektor mit Label wird nach Klick auf die Schaltfläche "neuer Vektor" erschienen. Mit einem Doppelcklick auf das Label
            kann der Name des Vektors festgelegt werden. Nach drücken der Entertaste wird der Name übernommen. Der Vektor kann als ganzer im Zeichenfeld verschoben werden. Mit der grauen Fläche an der Spitze kann
            Betrag und Phase des Vektors eingestellt werden. Mit einem Doppelclick auf den Vektor wird dieser samt Label gelöscht.
          </div>
        </div>

        <div class="helpDIV">
          <h1 class="helpH1">Hilfe zu der Ladefunktion:</h1>
          <img src="Data/BildHelp.gif" class="helpIMG">
          <div class="helpP">Nach auswahl eines eigenen Bildes wird dieses formatfüllend im Zeichenfeld dargestellt. Ein geladenes Bild ist in jedem Fall als solches
            ersichtlich.
          </div>
        </div>

        <!--<div class="helpDIV">
          <h1 class="helpH1">Hilfe zu den Vektoren:</h1>
          <img src="VerktorHelp.gif" class="helpIMG">
          <p class="helpP">Der Standard sagt nicht explizit, wie die letzte Zeile
            bei Blocksatz zu behandeln ist. Die aktuellen Browser stellen diese
            der Schreibrichtung folgend dar, als ob eine Eigenschaft text-align-last:start
            definiert sei. Wenn Sie in der letzten Zeile z.B. den Autor rechts
            platzieren wollen, können Sie text-align-last verwenden.
          </p>
        </div>

          <!--<div class="helpDIV">
          <h1 class="helpH1">Bedienungshinweise:</h1>
          <p class="helpP"> Das ist die integrierte Eingabemöglichkeit des Protokolls. Es besteht aus zwei grundlegenden Bereichen
            dem Bedienfeld und dem Zeichenfeld. Das Bedienfeld ist in drei Spalten unterteilt, diese werden später genauer
            beschrieben. Das Zeichenfeld ist der rot umrahmte Bereich. Die erste Spalte
            befasst sich mit der handschriftlichen Bearbeitung des Zeichenfeldes. Hier können für die Werkzeuge Stift und
            Radiergummi die Breite eingestellt werden (Hinweis: Die Breite bezieht sich auf beide Werkzeuge). Außerdem ist
            es möglich die Mienenfarbe des Stiftes einzustellen. Der Button mit der Aufschrift "Lösche Handschrift" löscht lediglich
            den Handbeschriebenen Layer. Mit dem Tool Hintergrund können Sie einen geeigneten Hintergrund festlegen. <br><br>
            Die zweite Spalte befasst sich mit den erstellen von Objekten. Diese werden nach Betätigung der jeweiligen Schaltfläche
            im Zeichenfeld erscheinen. Die jeweiligen Objekte besitzen angeheftete Schaltflächen. Der rote Kreis mit einem x in
            der Mitte löscht das jeweilige Objekt. Der graue Kreis versteckt die Interaktionsfelder des Objektes also die
            Schaltflächen und den Rahmen. Die Interaktionsfelder erscheinen automatisch beim Bewegen der Objekte wieder. Der
            Rahmen des Textfeldes verfügt außerdem über eine Breiteneinstellung und eine Möglichkeit zum Rotieren des Textes.
            Der Inhalt des Textfeldes kann mit einem Doppelklick auf den Text verändert werden. Die veränderrungen des Textes
            werden mit der Entertaste übernommen und das Textfeld kann wieder verschoben, rotiert und in der breite Verändert
            werden. Um einen Zeilenumbruch hinzuzufügen, benutzen Sie die Tastenkombination Shift und Enter. Das Objekt Gerade
            hat außerdem noch eine bunte Schaltfläche. Nach Betätigung dieser wird die Linienfarbe zufällig geändert. Das Tool
            Lade Bild ermöglicht es formatfüllend ein Hintergrundbild in die Zeichenebene einzubinden. Außerdem wurde die integrierte
            Eingabemöglichkeit um die Wertetabellenfunktion erweitert. Mit einem Klick auf die Schaltfläche "Neue Wertetabelle"
            bekommen Sie die Möglichkeit einen weiteren Graph zu erstellen. Um einen Graph zu erstellen wählen Sie zunächst ein
            geeignetes Koordinatensystem. Der Graph kann mithilfe des Inputs über der Tabelle beschriftet werden. Damit die Punkte
            richtig dargestellt werden, müssen die Werte mit den richtigen Beträgen bezüglich der Achsen in die Inputs eingegeben werden.
            Um mehr als einen Punkt darstellen zu können betätigen Sie schaltfläche "New Row". Gezeichnet und gelöscht wird der Graph mit
            der entsprechend beschrifteten Schaltfläche. (Hinweis: ändern sie zwichenzeitlich das KOS so muss die schaltfläche Show erneut
            betätigt werden.) Der Vektor wird durch den Punkt an der spitze des Pfeils in Betrag und Phase ge&auml;ndert. Durch ein Doppelclick
            auf den Pfeil wird der Vektor gelöscht.<br><br>
          </p>
        </div>-->
      </div>
    </div>

    <script>
      //Eigenes Modal ohne j-query
      // Get the modal
      var modal = document.getElementById("myModal");

      // Get the button that opens the modal
      var btn = document.getElementById("myBtn");

      // Get the colsedive element that closes the modal
      var div = document.getElementById("closeModal");

      // When the user clicks on the button, open the modal
      btn.onclick = function() {
        modal.style.display = "block";
      }

      // When the user clicks on <span> (x), close the modal
      div.onclick = function() {
        modal.style.display = "none";
      }

      // When the user clicks anywhere outside of the modal, close it
      window.onclick = function(event) {
        if (event.target == modal) {
          modal.style.display = "none";
        }
      }
    </script>

  </div>
  <!--end wrapper-->

  <div id="container"></div>

  <script>
    console.log("Hello!");

    hideCross('mdiv1');
    hideCross('mdiv2');

    /*if (is_touch_device()) { //ermöglicht zugroff auf andere touch events
      TouchEmulator();
      Konva.hitOnDragEnabled = true;
      Konva.captureTouchEventsEnabled = true;
    }*/

    const debugging = false;
    var strokeWidth = 10 //rahmen um Zeichenebene
    var scrollbarWidth = 18;
    var width = window.innerWidth - scrollbarWidth;
    var height = window.innerHeight - 45;
    var osziFlash = new Array; //eingelesene und verarbeitete csv datei
    var csvGroupCache = new Array; //speicherort für den render der Dateien

    /*// hier ist das virtuelle Kos eingepflegt hierzu debugging anschalten und auslesen
    max höhe und breite werden in console ausgegeben*/

    //1. lineare Kalibrierung

    var ursprungXoffset = width * 0.14; // virtueller ursprung in prozent von gesamtbreite
    var ursprungYoffset = height * 0.12; // virtueller ursprung in prozent von gesamthöhe
    var xDiffPerCent = 0.0614; // div schrittweite in Prozent von gesamtbreite
    var yDiffPerCent = 0.0776; // div schrittweite in Prozent von gesamthöhe
    var yDiffWeiteCH1 = 20; //schrittweite je div CH1 default Slot für alle KOS (also hier 20mA/div)
    var yDiffWeiteCH2 = 20; //schrittweite je div CH2 (also hier 20mA/div)
    var xDiffWeite = 1; //schrittweite je div (also hier 1V/div)

    //2. log Kalibrierung
    var lineStepOnLogLine = [0, 0.301, 0.176, 0.125, 0.097, 0.079, 0.067, 0.058, 0.051, 0.046]; //umwandlung linerarer abstand in log
    var firstDekadeEndeLOG = 1; //Startwert x Achse
    var ursprungXoffsetLOG = width * 0.04; // virtueller ursprung in prozent von gesamtbreite
    var xDiffDekPerCentLOG = 0.3409; // dekaden schrittweite in Prozent von gesamtbreite

    var ursprungYoffsetLOG = height * 0.9238; // virtueller ursprung in prozent von gesamthöhe
    var yDiffPerCentLOG = 0.0859; // div schrittweite in Prozent von gesamthöhe
    var yDiffWeiteLOG = 5; //schrittweite je div (also hier 1V/div)


    var platzHalterKali = [ursprungXoffset, ursprungYoffset, xDiffPerCent, yDiffPerCent, xDiffWeite, yDiffWeiteCH1, yDiffWeiteCH2];

    var backroundKalibrierungTab = [
      [0, 0, 0, 0, 0, 0],
      [width * 0.1423, height * 0.1191, 0.0614, 0.0776, 20, 1, 1], //1
      [width * 0.1223, height * 0.0684, 0.0651, 0.0531, 0.1, 0.1, 0.1], //2
      [width * 0.1073, height * 0.1836, 0.1014, 0.1018, 1, 0.1, 0.1], //3 dieser Slot ist derzeit nicht belegt
      [width * 0.1351, height * 0.1816, 0.0657, 0.1021, 1, 0.1, 0.1], //4
      [width * 0.3273, height * 0.5019, 0.0635, 0.1192, 1, 1, 1], //5 ozi Div
      platzHalterKali, //6
      platzHalterKali, //7
      platzHalterKali, //8
      [width * 0.3262, height * 0.5019, 0.3156, 0.1192, 0.24, 111.6, 111.6], //9
      [width * 0.0714, height * 0.0684, 0.0361, 0.0532, 5, 1, 1], //10
      [width * 0.0601, height * 0.0645, 0.0295, 0.0477, 100, 20, 20], //11

      //logarythmische x Kalibrierung
      [ursprungXoffsetLOG, ursprungYoffsetLOG, xDiffDekPerCentLOG, yDiffPerCentLOG, xDiffWeite, 5, firstDekadeEndeLOG], //12
      [ursprungXoffsetLOG, ursprungYoffsetLOG, xDiffDekPerCentLOG, yDiffPerCentLOG, xDiffWeite, 10, firstDekadeEndeLOG], //13

      [ursprungXoffset, ursprungYoffset, xDiffPerCent, yDiffPerCent, xDiffWeite, yDiffWeiteCH1, yDiffWeiteCH2] //letzte Zeile nicht verwendet
    ];

    var backroundKalibrierung = backroundKalibrierungTab[1];

    //_______________________________________________Initialisierung

    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;

    var stage = new Konva.Stage({
      container: 'container',
      width: width,
      height: height,
    });

    var image = new Konva.Image({
      image: canvas,
      x: 0,
      y: 0,
      stroke: 'red',
      strokeWidth: strokeWidth,
    });

    var text = new Konva.Text({ //debugtext
      x: 10,
      y: 10,
      fontFamily: 'Calibri',
      fontSize: 24,
      text: '',
      fill: 'black'
    });

    var circle = new Konva.Circle({
      x: stage.width() / 2,
      y: stage.height() / 2,
      radius: 1,
      fill: 'transparent',
      stroke: 'red',
      strokeWidth: 2
    });

    var context = canvas.getContext('2d');
    context.strokeStyle = '#000000';
    context.lineJoin = 'round';
    context.lineWidth = 1;

    //loadImageURL(context, "grid.png"); //lädt das bild in die "Zeichenebene" kann also radiert werden

    /*var editpic = document.getElementById('picincanvas'); // lädt bild nach fileeingabe in den kontext
    editpic.addEventListener('change', function() {

      if (editpic.files.length == 0) return;
      var readereditpic = new FileReader();
      readereditpic.addEventListener('load', function() {
        loadImageURL(context, readereditpic.result);
      });
      readereditpic.readAsDataURL(editpic.files[0]);
    });*/

    var isPaint = false;
    var lastPointerPosition;
    var mode = 'brush';
    var countGerade = 0;
    var countText = 0;
    var countImage = 0;

    //_______________________________________________ init gridding Kästchen

    var shadowOffset = 20;
    var tween = null;
    var blockSnapSize = 20;

    //_______________________________________________layerring

    var layer = new Konva.Layer(); //Zeichenlayer
    var backlayer = new Konva.Layer(); //Hintergrundbilder
    var circlelayer = new Konva.Layer(); //Layer für die zeichenforschau Damit aufsetzen suggerriert wird
    var textlayer = new Konva.Layer(); //elementlayer
    var gridGroup = new Konva.Group(); //Kästchenmuster

    /*var group = new Konva.Group();
    textlayer.add(group);

    var hammertime = new Hammer(group, {
      domEvents: true
    });*/

    circlelayer.add(circle);
    layer.add(image);
    textlayer.add(text);
    backlayer.add(gridGroup);

    stage.add(backlayer);
    stage.add(circlelayer);
    stage.add(layer);
    stage.add(textlayer);


    //_______________________________________________gridding Kästchen

    var padding = blockSnapSize;

    if (debugging) {

      console.log("_______________Info Gridding_______________");
      console.log("Breite: " + width);
      console.log("Kästchen: " + padding);
      console.log("Anzahl Kästchen: " + width / padding);
      console.log("_______________Info Kalibrierung_______________");
      console.log("** Klichen Sie den Ursprung und das Offset wird Ihnen Angezeigt **");
      console.log("Breite = " + width);
      console.log("Höhe = " + height);

      stage.on('click', (e) => {

        let Position = getPointerOnElement(stage);
        let x = Position.x;
        let y = Position.y;
        console.log("New Click New Offset");
        console.log("x-Offset = " + x / width);
        console.log("y-Offset = " + (height - y) / height);

      });
    }


    for (var i = 0; i < width / padding; i++) {
      let vertikalLine = new Konva.Line({
        points: [Math.round(i * padding) + 0.5, 0, Math.round(i * padding) + 0.5, height],
        stroke: '#ddd',
        strokeWidth: 1,
      });
      gridGroup.add(vertikalLine);
    }

    for (var j = 0; j < height / padding; j++) {
      let horizontalLine = new Konva.Line({
        points: [0, Math.round(j * padding), width, Math.round(j * padding)],
        stroke: '#ddd',
        strokeWidth: 0.5,
      });
      gridGroup.add(horizontalLine);
    }

    //_______________________________________________Arrow funktion

    var arrowCount = 0;

    function newArrow(layer) {

      arrowCount++;
      let name = "Vektor " + arrowCount;
      let arrowGroup = new Konva.Group({
        id: name,
      });

      var arrow = new Konva.Arrow({
        id: name,
        points: [blockSnapSize, blockSnapSize, blockSnapSize * 5, blockSnapSize],
        draggable: true,
        fill: 'black',
        stroke: 'black',
        strokeWidth: 4,
        shadowOffset: {
          x: 1,
          y: 1
        },
        hitStrokeWidth: 20,
        shadowOpacity: 0.4,
        pointerLength: blockSnapSize,
        pointerWidth: 0.5 * blockSnapSize,
      });

      let Punkt = new Konva.Circle({
        x: blockSnapSize * 5,
        y: blockSnapSize,
        radius: 13,
        fill: 'grey',
        stroke: 'black',
        draggable: true,
        opacity: 0.25,
        //strokeWidth: 2,
      });

      var tooltip = new Konva.Label({
        x: 170,
        y: 75,
        opacity: 0.75,
        draggable: true,
      });

      tooltip.add(
        new Konva.Tag({
          fill: 'black',
          pointerDirection: 'down',
          pointerWidth: 10,
          pointerHeight: 10,
          lineJoin: 'round',
          shadowColor: 'black',
          shadowBlur: 10,
          shadowOffsetX: 10,
          shadowOffsetY: 10,
          shadowOpacity: 0.5,
        })
      );

      let label = new Konva.Text({
        text: ' ',
        fontFamily: 'Calibri',
        fontSize: 18,
        padding: 5,
        fill: 'white',
      });

      setVektorName(label, arrow, blockSnapSize);

      tooltip.add(label);

      arrowGroup.add(arrow);
      arrowGroup.add(tooltip);
      arrowGroup.add(Punkt);

      Punkt.on('dragmove', (e) => {

        let p = arrow.getPoints();
        let posA = arrow.getPosition();
        let posP = Punkt.getPosition();

        p[2] = posP.x - posA.x;
        p[3] = posP.y - posA.y;
        arrow.setPoints(p);

        setVektorName(label, arrow, blockSnapSize);
        //label.text ="name" + betrag;

        stage.batchDraw();
      });

      arrow.on('dragmove', (e) => {
        let p = arrow.getPoints();
        let pos = arrow.getPosition();
        Punkt.position({
          x: p[2] + pos.x,
          y: p[3] + pos.y
        });
        stage.batchDraw();
      });

      arrow.on('dblclick dbltap', function() {
        let group = this.getParent();
        group.destroy();
        stage.draw();
      });

      tooltip.on('dblclick dbltap', () => {
        // create textarea over canvas with absolute position

        // first we need to find position for textarea
        // how to find it?

        // at first lets find position of text node relative to the stage:
        var textPosition = label.getAbsolutePosition();

        // then lets find position of stage container on the page:
        var stageBox = stage.container().getBoundingClientRect();

        // so position of textarea will be the sum of positions above:
        var areaPosition = {
          x: stageBox.left + textPosition.x,
          y: stageBox.top + textPosition.y,
        };

        // create textarea and style it
        var textarea = document.createElement('textarea');
        document.body.appendChild(textarea);

        textarea.value = arrow.id();
        textarea.style.position = 'absolute';
        textarea.style.top = areaPosition.y + 'px';
        textarea.style.left = areaPosition.x + 'px';
        textarea.style.width = label.width() + 'px';

        textarea.focus();

        textarea.addEventListener('keydown', function(e) {
          // hide on enter
          if (e.keyCode === 13) {
            arrow.id(textarea.value);
            setVektorName(label, arrow, blockSnapSize);
            stage.draw();
            document.body.removeChild(textarea);
          }
        });
      });

      textlayer.add(arrowGroup);
      stage.draw();

      showAsGrabbable(arrow);
      showAsGrabbable(label);
      showAsGrabbable(Punkt);
      makeItHover(Punkt, stage);
      makeItHover(arrow, stage);
    }

    //_______________________________________________ oszi control panel

    let osziControls = new Array;

    function newPanel(id, headline, layer, isTime, channel, x, y) {

      let einheit = ["s", "1"];
      let values = new Array();
      let valuesS = [
        ["0.01ms", 0.00001],
        ["0.02ms", 0.00002],
        ["0.05ms", 0.00005],
        ["0.1ms", 0.0001],
        ["0.2ms", 0.0002],
        ["0.5ms", 0.0005],
        ["1ms", 0.001]
      ];
      let valuesV = [
        ["0.01V", 0.01],
        ["0.02V", 0.02],
        ["0.05V", 0.05],
        ["0.1V", 0.1],
        ["0.2V", 0.2],
        ["0.5V", 0.5],
        ["1V", 1]
      ];

      if (isTime) {
        values = valuesS;
      } else {
        values = valuesV;
      }

      let count = roundDown(values.length / 2);
      if (isTime) {
        backroundKalibrierungTab[5][4] = values[count][1];
      } else {
        backroundKalibrierungTab[5][5] = values[count][1];
      }


      function makeItHighlight(objektReckt, objektArrow) {

        let colorBack = "lightgray";
        let colorFront = "gray";
        let colorBackPast = "gray";
        let colorFrontPast = "white";


        objektReckt.on('mouseover touchstart', function() {
          objektReckt.setAttrs({
            fill: colorBack
          });
          objektArrow.setAttrs({
            fill: colorFront
          });
        });

        objektReckt.on('mouseout touchend', function() {
          // set multiple properties at once with setAttrs
          objektReckt.setAttrs({
            fill: colorBackPast,
          });
          objektArrow.setAttrs({
            fill: colorFrontPast,
          });
        });

        objektReckt.on('mousedown', function() {
          objektArrow.setAttrs({
            fill: "red"
          });
        });

        objektReckt.on('mouseup', function() {
          objektArrow.setAttrs({
            fill: colorFrontPast,
          });
        });

        objektArrow.on('mouseover touchstart', function() {
          objektArrow.setAttrs({
            fill: colorFront,
          });

          objektReckt.setAttrs({
            fill: colorBack,
          });
        });

        objektArrow.on('mouseout touchend', function() {
          // set multiple properties at once with setAttrs
          objektArrow.setAttrs({
            fill: colorFrontPast,
          });
          objektReckt.setAttrs({
            fill: colorBackPast,
          });
        });

        objektArrow.on('mousedown', function() {
          objektArrow.setAttrs({
            fill: "red"
          });
        });

        objektArrow.on('mouseup', function() {
          objektArrow.setAttrs({
            fill: colorFrontPast,
          });
        });


      }

      var osziCtrlWidth = 120;
      var osziCtrlHeight = 80;
      var osziCtrlFontSize = 18;

      var setOszi = new Konva.Label({
        id: id + count,
        x: x,
        y: y,
        opacity: 0.75,
        draggable: true,

      });

      setOszi.add(
        new Konva.Rect({
          fill: 'lightgray',
          width: osziCtrlWidth,
          height: osziCtrlHeight,
          stroke: 'red',
          strokeWidth: 1,

        })
      );

      setOszi.add(
        new Konva.Text({
          width: osziCtrlWidth,
          height: osziCtrlHeight,
          text: headline,
          fontFamily: 'Calibri',
          fontSize: 22,
          align: 'center',
          fontStyle: 'bold',
          padding: 5,
          fill: 'black',
        })
      );


      var up = new Konva.Rect({
        id: "up" + id,
        x: 5,
        y: 10 + osziCtrlFontSize,
        width: 20,
        height: 20,
        fill: 'gray',
        shadowBlur: 3,
        cornerRadius: 2,
      });


      var down = new Konva.Rect({
        id: "down" + id,
        x: 5,
        y: 35 + osziCtrlFontSize,
        width: 20,
        height: 20,
        fill: 'gray',
        shadowBlur: 3,
        cornerRadius: 2,
      });


      var upArrow =
        new Konva.Text({
          id: "upArrow" + id,
          x: 28,
          y: 10 + osziCtrlFontSize,
          text: '<',
          fontFamily: 'Calibri',
          fontSize: 25,
          padding: 2,
          rotation: 90,
          fontStyle: 'bold',
          fill: 'white',
        });


      var downArrow =
        new Konva.Text({
          id: "downArrow" + id,
          x: 2,
          y: 73,
          text: '<',
          fontFamily: 'Calibri',
          fontSize: 25,
          padding: 2,
          rotation: 270,
          fontStyle: 'bold',
          fill: 'white',
        });

      var description = new Konva.Text({
        y: 9,
        width: osziCtrlWidth,
        height: osziCtrlHeight,
        text: values[count][0],
        fontFamily: 'Calibri',
        fontSize: 20,
        align: 'right',
        verticalAlign: 'middle',
        fontStyle: 'bold',
        padding: 10,
        fill: 'black',
      });

      setOszi.add(description);
      setOszi.add(up);
      setOszi.add(upArrow);
      setOszi.add(down);
      setOszi.add(downArrow);

      makeItHighlight(up, upArrow);
      makeItHighlight(down, downArrow);

      up.on('click touchstart', function() {
        if (count < values.length) {
          count++;
        }
        description.text(values[count][0]);
        if (isTime) {
          backroundKalibrierungTab[5][4] = values[count][1];
        } else {
          backroundKalibrierungTab[5][4 + channel] = values[count][1];
        }

        stage.batchDraw();
      });
      upArrow.on('click touchstart', function() {
        if (count < values.length - 1) {
          count++;
        }
        description.text(values[count][0]);
        if (isTime) {
          backroundKalibrierungTab[5][4] = values[count][1];
        } else {
          backroundKalibrierungTab[5][4 + channel] = values[count][1];
        }
        stage.batchDraw();
      });

      down.on('click touchstart', function() {
        if (count > 0) {
          count--;
        }
        description.text(values[count][0]);
        if (isTime) {
          backroundKalibrierungTab[5][4] = values[count][1];
        } else {
          backroundKalibrierungTab[5][4 + channel] = values[count][1];
        }
        stage.batchDraw();
      });
      downArrow.on('click touchstart', function() {
        if (count > 0) {
          count--;
        }
        description.text(values[count][0]);
        if (isTime) {
          backroundKalibrierungTab[5][4] = values[count][1];
        } else {
          backroundKalibrierungTab[5][4 + channel] = values[count][1];
        }
        stage.batchDraw();
      });

      showAsClickable(up);
      showAsClickable(upArrow);
      showAsClickable(down);
      showAsClickable(downArrow);


      layer.add(setOszi);
      return setOszi;

    }


    osziControls.push(newPanel("Zeit", "CH1/CH2", textlayer, true, 0, 0.7822 * width, 0.27 * height));
    osziControls.push(newPanel("VoltCH1", "CH1", textlayer, false, 1, 0.7282 * width, 0.704 * height));
    osziControls.push(newPanel("VoltCH2", "CH2", textlayer, false, 2, 0.7282 * width + 130, 0.704 * height));

    osziControls.forEach((objekt) => {
      objekt.hide();
      textlayer.draw();
    });

    //_______________________________________________background Bild

    var imageObj = new Image();

    imageObj.onload = function() {

      let choosen = document.getElementById('hintergrund').value;

      var background = new Konva.Image({
        draggable: false,
        x: strokeWidth * 0.8,
        y: strokeWidth * 0.8,
        image: imageObj,
        width: width - 2 * strokeWidth * 0.8,
        height: height - 2 * strokeWidth * 0.8,
      });

      // add the shape to the layer
      backlayer.add(background);

      if (choosen == 7) {
        gridGroup.show();
      } else {
        gridGroup.hide();
      }
      stage.draw();
    };

    imageObj.src = 'Data/invisible.svg';
    stage.draw(); //Initialisierungs Rendern

    function changeToolBackground() {
      let choosen = document.getElementById('hintergrund').value;
      imageObj.src = sources[choosen];
      backroundKalibrierung = backroundKalibrierungTab[choosen];
      console.log(choosen);
      if (choosen == 5) {
        osziControls.forEach((objekt) => {
          objekt.show();
          textlayer.draw();
        });
      } else {
        osziControls.forEach((objekt) => {
          objekt.hide();
          textlayer.draw();
        });
      }
    }

    //_______________________________________________vorschau der pinselgröße

    stage.on('mousedown touchstart', function() {

      layer.setZIndex(2);
      circlelayer.setZIndex(1);
      stage.draw();

      isPaint = true;
      lastPointerPosition = stage.getPointerPosition();

    });

    stage.on('mouseup touchend', function() {

      layer.setZIndex(1);
      circlelayer.setZIndex(2);
      stage.draw();

      isPaint = false;

    });


    //_______________________________________________move der zeichengröße und drawing

    function writeMessage(message) {
      text.text(message);
    }

    stage.on('mousemove touchmove', function() {

      var circlePos = getPointerOnElement(stage);
      var cx = circlePos.x;
      var cy = circlePos.y;

      circle.x(cx); //zeichenvorschau (kleiner roter kreis)
      circle.y(cy);
      circle.radius(pixcount.value * 0.5);
      stage.batchDraw();

    });

    // and core function - drawing
    image.on('mousemove touchmove', function() { //stage damit immer gezeichnet werden kann aber dadurch immer malen bei grabbing

      var touchPos = getPointerOnElement(stage);
      //  var tx = touchPos.x - ursprungXoffset;
      //  var ty = Math.abs(touchPos.y - height + ursprungYoffset);
      var tx = touchPos.x;
      var ty = touchPos.y;

      if (debugging) {
        writeMessage('x: ' + tx + ', y: ' + ty); //info mouspos
      }

      if (!isPaint) {
        return;
      }

      if (mode === 'brush') {
        context.globalCompositeOperation = 'source-over';

      }
      if (mode === 'eraser') {
        context.globalCompositeOperation = 'destination-out';

      }

      context.beginPath();

      var localPos = {
        x: lastPointerPosition.x - image.x(),
        y: lastPointerPosition.y - image.y()
      };

      context.moveTo(localPos.x, localPos.y);
      var pos = stage.getPointerPosition();
      localPos = {
        x: pos.x - image.x(),
        y: pos.y - image.y()
      };
      context.lineTo(localPos.x, localPos.y);
      context.closePath();
      context.stroke();

      lastPointerPosition = pos;
      layer.batchDraw();

    });

    // _______________________________________________Toolbar

    var Mousemode = document.getElementById('container');
    Mousemode.classList.add('pencil');

    var select = document.getElementById('Zeichentool');
    select.addEventListener('change', function() {
      mode = select.value;

      if (mode === 'brush') {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pencil');
      }
      if (mode === 'eraser') {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('eraser');
      }

    });

    var pixcount = document.getElementById('pix');
    pixcount.addEventListener('change', function() {

      context.lineWidth = pixcount.value;
      circle.radius(pixcount.value * 0.5); //faktor damit es einigermaßen stimmt pix und konva größe
      stage.draw();

    });

    function updateColor() {
      let picker = document.getElementById('pencilColor')
      context.strokeStyle = picker.value;
    }

    /*    var layerring = false;

      document.getElementById('zIndex').addEventListener( //versuche zu Layering vom benutzer eingefügte bilder bearbeiten
        'click',
        function() {

          toggleText('zIndex');
          layerring = !layerring;

          if (layerring) {
            backlayer.moveToBottom();
          } else {
            backlayer.moveToTop();
          }

          stage.draw();
        },
        false
      );*/

    //_________________________________________________________________________________images load in background

    function preview_image(event) {

      countImage = countImage + 1;

      var myImage = new Image(width - 2 * strokeWidth * 0.8, height - 2 * strokeWidth * 0.8);

      var reader = new FileReader();
      reader.onload = function() {
        myImage.src = reader.result;
      }

      var selectedFile = document.getElementById('pic').files[0];
      console.log(selectedFile);
      reader.readAsDataURL(event.target.files[0]);

      var bild = new Konva.Image({
        image: myImage,
        draggable: false,
        x: strokeWidth * 0.8,
        y: strokeWidth * 0.8,

      });

      const deleteButton = new Konva.Circle({
        x: 7 + countImage * 20,
        y: 20,
        radius: 10,
        fill: 'red'
      });
      textlayer.add(deleteButton);

      const deletezeichen = new Konva.Text({
        text: 'x',
        x: 2 + countImage * 20,
        y: 10,
        fontSize: charpix,
      });
      textlayer.add(deletezeichen);

      deleteButton.on(('touchstart click'), () => {
        deleteButton.destroy();
        deletezeichen.destroy();
        bild.destroy();
        stage.draw();
      });

      deletezeichen.on(('touchstart click'), () => {
        deleteButton.destroy();
        deletezeichen.destroy();
        bild.destroy();
        stage.draw();
      });

      deleteButton.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        this.setAttrs({
          fill: '#AA0000'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          this.setAttrs({
            fill: 'red'
          });
        }
      });

      deleteButton.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        this.setAttrs({
          fill: 'red'
        });
        textlayer.draw();
      });

      deletezeichen.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        deleteButton.setAttrs({
          fill: '#AA0000'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          deleteButton.setAttrs({
            fill: 'red'
          });
        }
      });

      deletezeichen.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        deleteButton.setAttrs({
          fill: 'red'
        });
        textlayer.draw();
      });

      setTimeout(function() { //verzögerung des renderns da das bild eine gewisse zeit braucht um zu laden ggf noch automatische berechnug in abhänigkeit der göße des bildes?

        backlayer.add(bild);
        backlayer.batchDraw();
        stage.draw();

      }, 100);

      return;

    }


    //________________________________________________________________________ textfeld

    //var charpix=pixcount;
    var charpix = 20;

    function createTextfeld() {

      countText = countText + 1;

      var textNode = new Konva.Text({
        text: 'Doppelclick zum Editieren.',
        x: 50 + countText * 10,
        y: 80 + countText * 10,
        fontSize: charpix,
        draggable: true,
        width: 200,
      });

      textlayer.add(textNode);

      var tr = new Konva.Transformer({
        node: textNode,
        enabledAnchors: ['middle-right'],
        // set minimum width of text
        boundBoxFunc: function(oldBox, newBox) {
          newBox.width = Math.max(30, newBox.width);
          return newBox;
        },
      });

      const deleteButton = new Konva.Circle({
        x: tr.getWidth() - 20,
        y: -15,
        radius: 10,
        fill: 'red'
      });
      tr.add(deleteButton);

      const deletezeichen = new Konva.Text({
        text: 'x',
        x: tr.getWidth() - 25,
        y: -25,
        fontSize: charpix,
      });
      tr.add(deletezeichen);

      const editButton = new Konva.Circle({
        x: tr.getWidth() - 0,
        y: -15,
        radius: 10,
        fill: 'grey',
      });
      tr.add(editButton);

      tr.on('transform', () => {
        drawing = false;
        deleteButton.x(tr.getWidth() - 20);
        deletezeichen.x(tr.getWidth() - 25);
        editButton.x(tr.getWidth() - 0);
      });

      deleteButton.on(('touchstart click'), () => {
        tr.destroy();
        textNode.destroy();
        textlayer.draw();
      });

      deletezeichen.on(('touchstart click'), () => {
        tr.destroy();
        textNode.destroy();
        textlayer.draw();
      });

      editButton.on(('touchstart click'), () => {
        tr.hide();
        textlayer.draw();
      });

      textNode.on('transform', function() {
        // reset scale, so only with is changing by transformer
        drawing = false;
        textNode.setAttrs({
          width: textNode.width() * textNode.scaleX(),
          scaleX: 1,
        });
      });

      textlayer.add(tr);

      textlayer.draw();

      //--------------------------Edit textfeld---------------------------------------------------
      //die guten touchevents......

      if (is_touch_device() == true) {
        //console.log("s_touch_devic");

        textNode.on(('touchstart'), () => {
          tr.show();
          textlayer.draw();
          if (doubletap() == true) {

            tr.hide();
            textNode.hide();
            textlayer.draw();


            var textPosition = textNode.absolutePosition();


            var stageBox = stage.container().getBoundingClientRect();


            var areaPosition = {
              x: stageBox.left + textPosition.x,
              y: stageBox.top + textPosition.y,
            };

            // create textarea and style
            var textarea = document.createElement('textarea');
            document.body.appendChild(textarea);

            textarea.value = textNode.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 'px';
            textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
            textarea.style.height =
              textNode.height() - textNode.padding() * 2 + 5 + 'px';
            textarea.style.fontSize = textNode.fontSize() + 'px';
            textarea.style.border = 'none';
            textarea.style.padding = '0px';
            textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden';
            textarea.style.background = 'none';
            textarea.style.outline = 'none';
            textarea.style.resize = 'none';
            textarea.style.lineHeight = textNode.lineHeight();
            textarea.style.fontFamily = textNode.fontFamily();
            textarea.style.transformOrigin = 'left top';
            textarea.style.textAlign = textNode.align();
            textarea.style.color = textNode.fill();
            rotation = textNode.rotation();
            var transform = '';
            if (rotation) {
              transform += 'rotateZ(' + rotation + 'deg)';
            }

            var px = 0;
            // also we need to slightly move textarea on firefox
            // because it jumps a bit
            var isFirefox =
              navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isFirefox) {
              px += 2 + Math.round(textNode.fontSize() / 20);
            }
            transform += 'translateY(-' + px + 'px)';

            textarea.style.transform = transform;

            // reset height
            textarea.style.height = 'auto';
            // after browsers resized it we can set actual value
            textarea.style.height = textarea.scrollHeight + 3 + 'px';

            textarea.focus();

            function removeTextarea() {
              textarea.parentNode.removeChild(textarea);
              window.removeEventListener('click', handleOutsideClick);
              textNode.show();
              tr.show();
              tr.forceUpdate();
              textlayer.draw();
            }

            function setTextareaWidth(newWidth) {
              if (!newWidth) {
                // set width placeholder
                newWidth = textNode.placeholder.length * textNode.fontSize();
              }
              //andere Browser andere Probleme
              var isSafari = /^((?!chrome|android).)*safari/i.test(
                navigator.userAgent
              );
              var isFirefox =
                navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
              if (isSafari || isFirefox) {
                newWidth = Math.ceil(newWidth);
              }

              var isEdge =
                document.documentMode || /Edge/.test(navigator.userAgent);
              if (isEdge) {
                newWidth += 1;
              }
              textarea.style.width = newWidth + 'px';
            }

            textarea.addEventListener('keydown', function(e) {
              // enter ende der bearbeitung
              // neue zeile shift + enter
              if (e.keyCode === 13 && !e.shiftKey) {
                textNode.text(textarea.value);
                removeTextarea();
                tr.hide();
                textlayer.draw();
              }
              // ESC abbruch
              if (e.keyCode === 27) {
                removeTextarea();
              }
            });

            textarea.addEventListener('keydown', function(e) {
              scale = textNode.getAbsoluteScale().x;
              setTextareaWidth(textNode.width() * scale);
              textarea.style.height = 'auto';
              textarea.style.height = textarea.scrollHeight + textNode.fontSize() + 'px';
            });

            function handleOutsideClick(e) {
              if (e.target !== textarea) {
                textNode.text(textarea.value);
                removeTextarea();
                tr.hide();
                textlayer.draw();
              }

              /*  if (e.target !== textNode) {
                  tr.hide();
                  textlayer.draw();
                }*/
            }

            setTimeout(() => {
              window.addEventListener('tochstart', handleOutsideClick);

            });
          }
        });


      } else {

        textNode.on(('mousedown'), () => {
          tr.show();
          textlayer.draw();
        });

        textNode.on(('dblclick'), () => {

          tr.hide();
          textNode.hide();
          textlayer.draw();


          var textPosition = textNode.absolutePosition();


          var stageBox = stage.container().getBoundingClientRect();


          var areaPosition = {
            x: stageBox.left + textPosition.x,
            y: stageBox.top + textPosition.y,
          };

          // create textarea and style
          var textarea = document.createElement('textarea');
          document.body.appendChild(textarea);

          textarea.value = textNode.text();
          textarea.style.position = 'absolute';
          textarea.style.top = areaPosition.y + 'px';
          textarea.style.left = areaPosition.x + 'px';
          textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
          textarea.style.height =
            textNode.height() - textNode.padding() * 2 + 5 + 'px';
          textarea.style.fontSize = textNode.fontSize() + 'px';
          textarea.style.border = 'none';
          textarea.style.padding = '0px';
          textarea.style.margin = '0px';
          textarea.style.overflow = 'hidden';
          textarea.style.background = 'none';
          textarea.style.outline = 'none';
          textarea.style.resize = 'none';
          textarea.style.lineHeight = textNode.lineHeight();
          textarea.style.fontFamily = textNode.fontFamily();
          textarea.style.transformOrigin = 'left top';
          textarea.style.textAlign = textNode.align();
          textarea.style.color = textNode.fill();
          rotation = textNode.rotation();
          var transform = '';
          if (rotation) {
            transform += 'rotateZ(' + rotation + 'deg)';
          }

          var px = 0;
          // also we need to slightly move textarea on firefox
          // because it jumps a bit
          var isFirefox =
            navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
          if (isFirefox) {
            px += 2 + Math.round(textNode.fontSize() / 20);
          }
          transform += 'translateY(-' + px + 'px)';

          textarea.style.transform = transform;

          // reset height
          textarea.style.height = 'auto';
          // after browsers resized it we can set actual value
          textarea.style.height = textarea.scrollHeight + 3 + 'px';

          textarea.focus();

          function removeTextarea() {
            textarea.parentNode.removeChild(textarea);
            window.removeEventListener('click', handleOutsideClick);
            textNode.show();
            tr.show();
            tr.forceUpdate();
            textlayer.draw();
          }

          function setTextareaWidth(newWidth) {
            if (!newWidth) {
              // set width placeholder
              newWidth = textNode.placeholder.length * textNode.fontSize();
            }
            //andere Browser andere Probleme
            var isSafari = /^((?!chrome|android).)*safari/i.test(
              navigator.userAgent
            );
            var isFirefox =
              navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            if (isSafari || isFirefox) {
              newWidth = Math.ceil(newWidth);
            }

            var isEdge =
              document.documentMode || /Edge/.test(navigator.userAgent);
            if (isEdge) {
              newWidth += 1;
            }
            textarea.style.width = newWidth + 'px';
          }

          textarea.addEventListener('keydown', function(e) {
            // enter ende der bearbeitung
            // neue zeile shift + enter
            if (e.keyCode === 13 && !e.shiftKey) {
              textNode.text(textarea.value);
              removeTextarea();
              tr.hide();
              textlayer.draw();
            }
            // ESC abbruch
            if (e.keyCode === 27) {
              removeTextarea();
            }
          });

          textarea.addEventListener('keydown', function(e) {
            scale = textNode.getAbsoluteScale().x;
            setTextareaWidth(textNode.width() * scale);
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + textNode.fontSize() + 'px';
          });

          function handleOutsideClick(e) {
            if (e.target !== textarea) {
              textNode.text(textarea.value);
              removeTextarea();
              tr.hide();
              textlayer.draw();
            }

            /*  if (e.target !== textNode) {
                tr.hide();
                textlayer.draw();
              }*/
          }

          setTimeout(() => {
            window.addEventListener('click', handleOutsideClick);

          });
        });

      }
      //??????????????????????????????????????????????????????????????????????????????????????????????????hover efects textarea Buttons

      editButton.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        this.setAttrs({
          fill: '#CCCCCC'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          this.setAttrs({
            fill: 'grey'
          });
        }
      });

      editButton.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        this.setAttrs({
          fill: 'grey'
        });
        textlayer.draw();
      });

      deleteButton.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        this.setAttrs({
          fill: '#AA0000'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          this.setAttrs({
            fill: 'red'
          });
        }
      });

      deleteButton.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        this.setAttrs({
          fill: 'red'
        });
        textlayer.draw();
      });

      deletezeichen.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        deleteButton.setAttrs({
          fill: '#AA0000'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          deleteButton.setAttrs({
            fill: 'red'
          });
        }
      });

      deletezeichen.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        deleteButton.setAttrs({
          fill: 'red'
        });
        textlayer.draw();
      });

      textNode.on('mouseover', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('pointer');
        Mousemode.classList.add('grabbable');
      });

      textNode.on('mouseout', function() {

        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
      });

    }

    //_________________________________________________________________________________export tool
    document.getElementById("exportInput").addEventListener('keypress', handleInputKeydown, false);

    function downloadURI(uri, name) {
      var link = document.createElement('a');
      link.download = name;
      link.href = uri;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      delete link;
      return;
    }

    function handleInputKeydown(event) {
      let keyCode = event.which;
      if (keyCode === 13) {
        downloadPic();
      }
      return;
    }

    function downloadPic() {

      let image = stage.toDataURL().replace("image/png", "image/octet-stream");
      console.log(image);
      let link = document.createElement('a');
      let DataName = document.getElementById("exportInput");
      if (DataName.value == "") {
        downloadURI(image, "ZT.png");
      } else {
        if (DataName.value.search(".png") > -1) {
          downloadURI(image, DataName.value);
        } else {
          downloadURI(image, DataName.value + ".png");
        }
      }
      return;
    }

    //_________________________________________________________________________________line tool

    function readpoints(id, idDeleteButton, idShowButton, graph) {
      let choosen = document.getElementById('hintergrund').value;
      let logKOS = false;
      if (choosen == 12 || choosen == 13) {
        logKOS = true;
      }

      let labelText = document.getElementById(graph);
      let key = graph.replace('Graph', '');
      //console.log(parseInt(key, 10));

      let color = getRandomColor();
      var label = new Konva.Label({
        x: 75,
        y: 50 + key * 25,
        draggable: true
      });

      // add a tag to the label
      label.add(new Konva.Tag({
        fill: '#bbb',
        stroke: color,
        shadowColor: 'black',
        shadowBlur: 3,
        shadowOffset: [10, 10],
        shadowOpacity: 0.7,
        lineJoin: 'round',
        pointerDirection: 'right',
        pointerWidth: 10,
        pointerHeight: 10,
        cornerRadius: 5
      }));

      // add text to the label
      label.add(new Konva.Text({
        text: labelText.value,
        fontSize: 12,
        lineHeight: 1.2,
        padding: 2,
        fill: color
      }));

      showAsGrabbable(label);

      var group = new Konva.Group({});
      textlayer.add(group);
      group.add(label);

      var punkte = get(id);

      // eingebenen Punkte werden auf das bild angepasst
      //var backroundKalibrierung[ursprungXoffset, ursprungYoffset, xDiffPerCent, yDiffPerCent, xDiffWeite, yDiffWeite];
      for (var i = 0; i < punkte.length; i++) {
        if (i % 2 == 1) {
          punkte[i] = ((punkte[i] / backroundKalibrierung[5]) * (backroundKalibrierung[3] * height) - height + backroundKalibrierung[1]) * -1;
        } else {
          if (logKOS) {
            let eingabe = punkte[i];
            eingabe = eingabe * 1.001 //das ist dirty code, sorry aber funktioniert :/
            let dekade = 0;
            let extraOff = 0;
            while (eingabe > 1) {
              eingabe = eingabe / 10;
              dekade++;
            }
            let k = 0;
            let rest = eingabe * 10 - roundDown(eingabe * 10);

            for (k = 1; k <= eingabe * 10; k++) {
              extraOff = extraOff + lineStepOnLogLine[k - 1];
            }

            let xxOff = lineStepOnLogLine[eingabe | 0] * (-(eingabe | 0) * 10 + eingabe * 10);
            punkte[i] = dekade * backroundKalibrierung[2] * width + extraOff * backroundKalibrierung[2] * width + backroundKalibrierung[0] + rest * lineStepOnLogLine[k - 1] * backroundKalibrierung[2] * width;

            if (debugging) {
              console.log("Rest: " + rest);
              console.log("K: " + k);
              console.log("lineStepOnLogLine[k-1]: " + lineStepOnLogLine[k - 1]);
              console.log("xxOff: " + -(eingabe | 0) * 10 + eingabe * 10);
              console.log("extraOff: " + extraOff);
              console.log("Ausgabe: " + punkte[i]);
            }


          } else {
            punkte[i] = (punkte[i] / backroundKalibrierung[4]) * (backroundKalibrierung[2] * width) + backroundKalibrierung[0];
          }
        }
      }

      //kann nicgt in erstes array da die werte erst vollstandig gewandelt werden müssen
      for (var k = 0; k < punkte.length; k = k + 2) {
        var point = new Konva.Circle({
          x: punkte[k],
          y: punkte[k + 1],
          radius: 5,
          fill: color,
          stroke: 'black',
          strokeWidth: 4,
        });
        group.add(point);
      }

      if (debugging) {
        console.log("_______________Info Gelesene Punkte_______________");
        console.log(punkte);
      }

      var line = new Konva.Line({
        points: punkte,
        tension: 0.5,
        //bezier: true,
        strokeWidth: 3,
        hitStrokeWidth: 20,
        stroke: color
      });

      group.add(line);


      document.getElementById(idDeleteButton).addEventListener(
        'click',
        function() {
          group.destroy();
          stage.draw();
        },
        false
      );


      document.getElementById(idShowButton).addEventListener(
        'click',
        function() {
          group.destroy();
          stage.draw();
        },
        false
      );



      stage.draw();

    }
    //_________________________________________________________________________________csv tool
    function showcsv(lines, channel) {

      let group = drawGraph(lines, channel);
      csvGroupCache[channel] = group;

      let eventsToDestroy = new Array;

      let upZeit = stage.findOne('#upZeit');
      let downZeit = stage.findOne('#downZeit');
      let upArrowZeit = stage.findOne('#upArrowZeit');
      let downArrowZeit = stage.findOne('#downArrowZeit');

      if (channel == 1) {
        let upVoltCH1 = stage.findOne('#upVoltCH1');
        let downVoltCH1 = stage.findOne('#downVoltCH1');
        let upArrowVoltCH1 = stage.findOne('#upArrowVoltCH1');
        let downArrowVoltCH1 = stage.findOne('#downArrowVoltCH1');
        //let reloadButtonCH1 = document.getElementById('reloadButtonCH1');
        eventsToDestroy = [upZeit, downZeit, upArrowZeit, downArrowZeit, upVoltCH1, downVoltCH1, upArrowVoltCH1, downArrowVoltCH1];
      } else {
        let upVoltCH2 = stage.findOne('#upVoltCH2');
        let downVoltCH2 = stage.findOne('#downVoltCH2');
        let upArrowVoltCH2 = stage.findOne('#upArrowVoltCH2');
        let downArrowVoltCH2 = stage.findOne('#downArrowVoltCH2');
        //let reloadButtonCH2 = document.getElementById('reloadButtonCH2');
        eventsToDestroy = [upZeit, downZeit, upArrowZeit, downArrowZeit, upVoltCH2, downVoltCH2, upArrowVoltCH2, downArrowVoltCH2];
      }

      eventsToDestroy.forEach((objekt, i) => { //events nochmal überarbeiten sodass ch1 group auf events hört bei zeitumstellung
        objekt.addEventListener(
          'click.event1',
          function() {
            eventsToDestroy.forEach((objekt) => {
              objekt.off('click.event1');
            });
            if (typeof csvGroupCache[1] !== 'undefined') {
              csvGroupCache[1].destroy();
              showcsv(osziFlash[1], 1);
            }

            if (typeof csvGroupCache[2] !== 'undefined') {
              csvGroupCache[2].destroy();
              showcsv(osziFlash[2], 2);
            }

            stage.draw();
          },
          false
        );
      });
    }

    function drawGraph(lines, channel) {

      channel = (typeof channel !== 'undefined') ? channel : 1;
      let choosen = document.getElementById('hintergrund').value;
      let qualitat = document.getElementById('quali' + channel);
      let f = document.getElementById('f');
      let numP = parseFloat(qualitat.value);
      let labelText = "CSVData " + channel;
      lines.shift(); //erste nichtsagende einheitsangabe weg
      let color = '#000000';

      if (typeof csvGroupCache[channel] !== 'undefined') {
        csvGroupCache[channel].destroy();
      }

      if (channel == 1) {
        color = '#0000FF'
      } else {
        color = '#00FF00'
      }

      var label = new Konva.Label({
        x: 75,
        y: 200,
        draggable: true
      });

      // add a tag to the label
      label.add(new Konva.Tag({
        fill: '#bbb',
        stroke: color,
        shadowColor: 'black',
        shadowBlur: 3,
        shadowOffset: [10, 10],
        shadowOpacity: 0.7,
        lineJoin: 'round',
        pointerDirection: 'right',
        pointerWidth: 10,
        pointerHeight: 10,
        cornerRadius: 5
      }));

      // add text to the label
      label.add(new Konva.Text({
        text: labelText,
        fontSize: 12,
        lineHeight: 1.2,
        padding: 2,
        fill: color
      }));

      showAsGrabbable(label);

      var group = new Konva.Group({});
      textlayer.add(group);
      group.add(label);

      //console.log(qualitat.value);

      let punkte = new Array();
      for (var i = 0; i < lines.length; i = i + numP) {
        punkte.push(parseFloat(lines[i][0]));
        punkte.push(parseFloat(lines[i][1]));
      }

      //  console.log(punkte);

      // eingebenen Punkte werden auf das bild angepasst
      //var backroundKalibrierung[ursprungXoffset, ursprungYoffset, xDiffPerCent, yDiffPerCent, xDiffWeite, yDiffWeite];
      for (var i = 0; i < punkte.length; i++) {
        if (i % 2 == 1) {
          punkte[i] = ((punkte[i] / backroundKalibrierung[4 + channel]) * (backroundKalibrierung[3] * height) - height + backroundKalibrierung[1]) * -1;
        } else {
          punkte[i] = (punkte[i] / backroundKalibrierung[4]) * (backroundKalibrierung[2] * width) + backroundKalibrierung[0];
        }
      }


      //kann nicgt in erstes array da die werte erst vollstandig gewandelt werden müssen
      for (var k = 0; k < punkte.length; k = k + 2) {
        var point = new Konva.Circle({
          x: punkte[k],
          y: punkte[k + 1],
          radius: 5,
          fill: color,
          stroke: 'black',
          strokeWidth: 4,
        });
        group.add(point);
      }

      var line = new Konva.Line({
        points: punkte,
        tension: 0.5,
        //bezier: true,
        strokeWidth: 3,
        hitStrokeWidth: 20,
        stroke: color
      });

      group.add(line);
      stage.draw();

      return group;
    }
    //_________________________________________________________________________________Gerade tool

    function createLine() {

      //??????????????????????????????????????????????????????init
      countGerade = countGerade + 1;

      var p1 = new Konva.Circle({
        x: stage.width() / 2 + (10 * countGerade),
        y: stage.height() / 2 + (10 * countGerade),
        radius: 10,
        fill: 'grey',
        stroke: 'black',
        strokeWidth: 1,
        draggable: true,
      });

      var positionP1 = p1.absolutePosition();

      var p2 = new Konva.Circle({
        x: stage.width() / 2 + 100 + (10 * countGerade),
        y: stage.height() / 2 + (10 * countGerade),
        radius: 10,
        fill: 'grey',
        stroke: 'black',
        strokeWidth: 1,
        draggable: true,
      });

      var positionP2 = p2.absolutePosition();

      var line = new Konva.Line({
        points: [positionP1.x, positionP1.y, positionP2.x, positionP2.y],
        stroke: getRandomColor(),
        strokeWidth: 3,
        lineCap: 'round',
        lineJoin: 'round',
        tension: 1,
        draggable: false,
      });

      var tr = new Konva.Transformer({ // nur um die Buttons anzuheften und dadurch ein Interface zu erstellen
        node: line,
        enabledAnchors: [],
        rotateEnabled: false,
      });

      const deleteButton = new Konva.Circle({
        x: tr.getWidth() - 20,
        y: -20,
        radius: 10,
        fill: 'red'
      });
      tr.add(deleteButton);

      const deletezeichen = new Konva.Text({
        text: 'x',
        x: tr.getWidth() - 25,
        y: -30,
        fontSize: charpix,
      });
      tr.add(deletezeichen);


      const strokeButtonColor = new Konva.Circle({
        x: tr.getWidth() - 40,
        y: -20,
        radius: 10,
        fillRadialGradientStartPoint: {
          x: 0,
          y: 0
        },
        fillRadialGradientStartRadius: 0,
        fillRadialGradientEndPoint: {
          x: 0,
          y: 0
        },
        fillRadialGradientEndRadius: 8,
        fillRadialGradientColorStops: [0, 'red', 0.5, 'yellow', 1, 'blue'],

      });
      tr.add(strokeButtonColor);

      const editButton = new Konva.Circle({
        x: tr.getWidth() - 0,
        y: -20,
        radius: 10,
        fill: 'grey'
      });
      tr.add(editButton);


      textlayer.add(tr);
      // add the shapes to the layer
      textlayer.add(p1);
      textlayer.add(p2);
      textlayer.add(line);
      line.moveToBottom();
      textlayer.draw();

      //??????????????????????????????????????????????????????Aktionshandling

      p1.on('dragmove', function() {
        tr.show();
        drawing = false;
        positionP1 = p1.absolutePosition();

        line.setAttrs({
          points: [positionP1.x, positionP1.y, positionP2.x, positionP2.y],
        });

        deleteButton.x(tr.getWidth() - 20);
        deletezeichen.x(tr.getWidth() - 25);
        editButton.x(tr.getWidth() - 0);
        strokeButtonColor.x(tr.getWidth() - 40);
        textlayer.batchDraw();

      });

      p2.on('dragmove', function() {
        tr.show();
        drawing = false;
        positionP2 = p2.absolutePosition();

        line.setAttrs({
          points: [positionP1.x, positionP1.y, positionP2.x, positionP2.y],
        });

        deleteButton.x(tr.getWidth() - 20);
        deletezeichen.x(tr.getWidth() - 25);
        editButton.x(tr.getWidth() - 0);
        strokeButtonColor.x(tr.getWidth() - 40);
        textlayer.batchDraw();

      });

      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!deletereact

      deleteButton.on(('touchstart click'), () => {
        tr.destroy();
        line.destroy();
        p1.destroy();
        p2.destroy();
        stage.draw();
      });

      deletezeichen.on(('touchstart click'), () => {
        tr.destroy();
        line.destroy();
        p1.destroy();
        p2.destroy();
        stage.draw();
      });

      strokeButtonColor.on(('click touchstart'), () => {
        line.setAttrs({
          stroke: getRandomColor(),
        });
        stage.draw();
      });

      editButton.on(('click touchstart'), () => {
        tr.hide();
        stage.draw();
      });

      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! hover

      p2.on('mouseover', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('pointer');
        Mousemode.classList.add('grabbable');
      });

      p1.on('mouseover', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('pointer');
        Mousemode.classList.add('grabbable');
      });

      p2.on('mouseout', function() {

        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
      });

      p1.on('mouseout', function() {

        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }

      });

      strokeButtonColor.on('mouseover touchstart', function() {

        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');

        this.setAttrs({
          fillRadialGradientStartPoint: {
            x: 0,
            y: 0
          },
          fillRadialGradientStartRadius: 0,
          fillRadialGradientEndPoint: {
            x: 0,
            y: 0
          },
          fillRadialGradientEndRadius: 8,
          fillRadialGradientColorStops: [0, 'blue', 0.5, 'yellow', 1, 'red'],
        });
        textlayer.draw();
      });

      strokeButtonColor.on('mouseout touchend', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        this.setAttrs({
          fillRadialGradientStartPoint: {
            x: 0,
            y: 0
          },
          fillRadialGradientStartRadius: 0,
          fillRadialGradientEndPoint: {
            x: 0,
            y: 0
          },
          fillRadialGradientEndRadius: 8,
          fillRadialGradientColorStops: [0, 'red', 0.5, 'yellow', 1, 'blue'],
        });
        textlayer.draw();
      });


      editButton.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        this.setAttrs({
          fill: '#CCCCCC'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          this.setAttrs({
            fill: 'grey'
          });
        }
      });

      editButton.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        this.setAttrs({
          fill: 'grey'
        });
        textlayer.draw();
      });


      deleteButton.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        this.setAttrs({
          fill: '#AA0000'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          this.setAttrs({
            fill: 'red'
          });
        }
      });

      deleteButton.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        this.setAttrs({
          fill: 'red'
        });
        textlayer.draw();
      });

      deletezeichen.on('mouseover touchstart', function() {
        Mousemode.classList.remove('pencil');
        Mousemode.classList.remove('eraser');
        Mousemode.classList.remove('grabbable');
        Mousemode.classList.add('pointer');
        deleteButton.setAttrs({
          fill: '#AA0000'
        });
        textlayer.draw();

        if (is_touch_device()) { //da nach touchstart ist das objekt weg wodurch nich touchend getriggert wird
          deleteButton.setAttrs({
            fill: 'red'
          });
        }
      });

      deletezeichen.on('mouseout', function() {
        if (mode === 'brush') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('pencil');
        }
        if (mode === 'eraser') {
          Mousemode.classList.remove('pencil');
          Mousemode.classList.remove('pointer');
          Mousemode.classList.remove('eraser');
          Mousemode.classList.remove('grabbable');
          Mousemode.classList.add('eraser');
        }
        // set multiple properties at once with setAttrs
        deleteButton.setAttrs({
          fill: 'red'
        });
        textlayer.draw();
      });

    }

    //_______________________________________________Bedienungsanweisung anzeigen lassen

    function hilfe() {

      $(function() {
        $("#dialog").dialog({
          height: height * 0.8,
          width: width * 0.8,
        });
      });
    }

    function clearContext() {

      context.clearRect(0, 0, canvas.width, canvas.height);
      stage.draw();

    }
  </script>

  <div id="dialog" title="Bedienungsanweisung:" hidden>
    <p> Das ist die integrierte Eingabemöglichkeit des Protokolls. Es besteht aus zwei grundlegenden Bereichen
      dem Bedienfeld und dem Zeichenfeld. Das Bedienfeld ist in drei Spalten unterteilt, diese werden später genauer
      beschrieben. Das Zeichenfeld ist der rot umrahmte Bereich. Die erste Spalte
      befasst sich mit der handschriftlichen Bearbeitung des Zeichenfeldes. Hier können für die Werkzeuge Stift und
      Radiergummi die Breite eingestellt werden (Hinweis: Die Breite bezieht sich auf beide Werkzeuge). Außerdem ist
      es möglich die Mienenfarbe des Stiftes einzustellen. Der Button mit der Aufschrift "Lösche Handschrift" löscht lediglich
      den Handbeschriebenen Layer. Mit dem Tool Hintergrund können Sie einen geeigneten Hintergrund festlegen. <br><br>
      Die zweite Spalte befasst sich mit den erstellen von Objekten. Diese werden nach Betätigung der jeweiligen Schaltfläche
      im Zeichenfeld erscheinen. Die jeweiligen Objekte besitzen angeheftete Schaltflächen. Der rote Kreis mit einem x in
      der Mitte löscht das jeweilige Objekt. Der graue Kreis versteckt die Interaktionsfelder des Objektes also die
      Schaltflächen und den Rahmen. Die Interaktionsfelder erscheinen automatisch beim Bewegen der Objekte wieder. Der
      Rahmen des Textfeldes verfügt außerdem über eine Breiteneinstellung und eine Möglichkeit zum Rotieren des Textes.
      Der Inhalt des Textfeldes kann mit einem Doppelklick auf den Text verändert werden. Die veränderrungen des Textes
      werden mit der Entertaste übernommen und das Textfeld kann wieder verschoben, rotiert und in der breite Verändert
      werden. Um einen Zeilenumbruch hinzuzufügen, benutzen Sie die Tastenkombination Shift und Enter. Das Objekt Gerade
      hat außerdem noch eine bunte Schaltfläche. Nach Betätigung dieser wird die Linienfarbe zufällig geändert. Das Tool
      Lade Bild ermöglicht es formatfüllend ein Hintergrundbild in die Zeichenebene einzubinden. Außerdem wurde die integrierte
      Eingabemöglichkeit um die Wertetabellenfunktion erweitert. Mit einem Klick auf die Schaltfläche "Neue Wertetabelle"
      bekommen Sie die Möglichkeit einen weiteren Graph zu erstellen. Um einen Graph zu erstellen wählen Sie zunächst ein
      geeignetes Koordinatensystem. Der Graph kann mithilfe des Inputs über der Tabelle beschriftet werden. Damit die Punkte
      richtig dargestellt werden, müssen die Werte mit den richtigen Beträgen bezüglich der Achsen in die Inputs eingegeben werden.
      Um mehr als einen Punkt darstellen zu können betätigen Sie schaltfläche "New Row". Gezeichnet und gelöscht wird der Graph mit
      der entsprechend beschrifteten Schaltfläche. (Hinweis: ändern sie zwichenzeitlich das KOS so muss die schaltfläche Show erneut
      betätigt werden.)

      <br><br>

    </p>
  </div>

</body>

</html>
